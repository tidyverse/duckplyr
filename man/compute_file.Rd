% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/compute_file.R
\name{compute_file}
\alias{compute_file}
\alias{compute_parquet}
\alias{compute_csv}
\title{Compute results to a file}
\usage{
compute_parquet(x, path, ..., lazy = NULL, options = NULL)

compute_csv(x, path, ..., lazy = NULL, options = NULL)
}
\arguments{
\item{x}{A data frame, data frame extension (e.g. a tibble), or a lazy
data frame (e.g. from dbplyr or dtplyr). See \emph{Methods}, below, for more
details.}

\item{path}{The path to store the result in.}

\item{...}{These dots are for future extensions and must be empty.}

\item{lazy}{Set to \code{TRUE} to return a lazy or \code{FALSE} to return an eager data frame,
see the "Eager and lazy" section in \code{\link[=duckdb_tibble]{duckdb_tibble()}}.
The default is to inherit the lazyness of the input.}

\item{options}{A list of additional options to pass to create the storage format,
see \url{https://duckdb.org/docs/data/parquet/overview#writing-to-parquet-files}
or \url{https://duckdb.org/docs/data/csv/overview#writing-using-the-copy-statement}
for details.}
}
\description{
These functions apply to (lazy) duckplyr frames.
They executes a query and stores the results in a flat file.
The result is a duckplyr frame that can be used with subsequent dplyr verbs.

\code{compute_parquet()} creates a Parquet file.

\code{compute_csv()} creates a CSV file.
}
\examples{
library(duckplyr)
df <- data.frame(x = c(1, 2))
df <- mutate(df, y = 2)
path <- tempfile(fileext = ".parquet")
df <- compute_parquet(df, path)
explain(df)
}
\seealso{
\code{\link[=compute.duckplyr_df]{compute.duckplyr_df()}}, \code{\link[dplyr:compute]{dplyr::collect()}}
}
