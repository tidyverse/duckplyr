---
title: "Use of duckplyr in other packages"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{developers}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
clean_output <- function(x, options) {
  x <- gsub("0x[0-9a-f]+", "0xdeadbeef", x)
  x <- gsub("dataframe_[0-9]*_[0-9]*", "      dataframe_42_42      ", x)
  x <- gsub("[0-9]*\\.___row_number ASC", "42.___row_number ASC", x)
  x <- gsub("â”€", "-", x)
  x
}

local({
  hook_source <- knitr::knit_hooks$get("document")
  knitr::knit_hooks$set(document = clean_output)
})

knitr::opts_chunk$set(
  collapse = TRUE,
  eval = identical(Sys.getenv("IN_PKGDOWN"), "true") || (getRversion() >= "4.1" && rlang::is_installed(c("conflicted", "nycflights13"))),
  comment = "#>"
)

Sys.setenv(DUCKPLYR_FALLBACK_COLLECT = 0)
```

```{r attach}
library(conflicted)
library(dplyr)
conflict_prefer("filter", "dplyr")
```

## Use of duckplyr for individual data frames

To enable duckplyr **for individual data frames instead of session wide**,

- do **not** load duckplyr with `library()`.
- use `duckplyr::as_duckdb_tibble()` as the first step in your pipe, without attaching the package.

```{r}
unfunneled <-
  duckplyr::flights_df() |>
  duckplyr::as_duckdb_tibble() |>
  filter(!is.na(arr_delay), !is.na(dep_delay)) |>
  mutate(inflight_delay = arr_delay - dep_delay) |>
  summarize(
    .by = c(year, month),
    mean_inflight_delay = mean(inflight_delay),
    median_inflight_delay = median(inflight_delay),
  ) |>
  filter(month <= 6)
```

The result is a tibble, with its own class.

```{r}
class(unfunneled)
names(unfunneled)
```

DuckDB is responsible for eventually carrying out the operations.
Despite the late filter, the summary is not computed for the months in the second half of the year.

```{r}
unfunneled |>
  explain()
```

All data frame operations are supported.
Computation happens upon the first request.

```{r}
unfunneled$mean_inflight_delay
```

After the computation has been carried out, the results are preserved and available immediately:

```{r}
unfunneled
```

## Funneling

The default mode for `as_duckdb_tibble()` is unfunneled.
This allows applying all data frame operations on the results, including column subsetting or retrieving the number of rows.
In addition, if an operation cannot be carried out by duckdb, the dplyr fallback is used transparently.
Use `funnel = TRUE` to ensure that all operations are carried out by DuckDB, or fail.
This is also the default for the ingestion functions such as `read_parquet_duckdb()`.

```{r}
funneled <-
  duckplyr::flights_df() |>
  duckplyr::as_duckdb_tibble(funnel = TRUE)
```

Columns or the row count cannot be accessed directly in this mode:

```{r error = TRUE}
nrow(funneled)
```

Also, operations that are not (yet) supported will fail:

```{r error = TRUE}
funneled |>
  mutate(inflight_delay = arr_delay - dep_delay) |>
  summarize(
    .by = c(year, month),
    mean_inflight_delay = mean(inflight_delay, na.rm = TRUE),
    median_inflight_delay = median(inflight_delay, na.rm = TRUE),
  )
```

See `vignette("limits")` for current limitations, and the contributing guide for how to add support for additional operations.
