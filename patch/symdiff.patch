diff --git b/R/symdiff.R a/R/symdiff.R
index f97c5d5d..ad890517 100644
--- b/R/symdiff.R
+++ a/R/symdiff.R
@@ -1,10 +1,47 @@
 # Generated by 02-duckplyr_df-methods.R
+#' @rdname symdiff.duckplyr_df
 #' @export
 symdiff.duckplyr_df <- function(x, y, ...) {
   # Our implementation
-  rel_try(NULL,
-    "No relational implementation for symdiff()" = TRUE,
+  check_dots_empty()
+  check_compatible(x, y)
+
+  x_names <- names(x)
+  y_names <- names(y)
+  if (identical(x_names, y_names)) {
+    # Ensure identical() is very cheap
+    y_names <- x_names
+  }
+
+  rel_try(list(name = "symdiff", x = x, y = y),
+    "No duplicate names" = !identical(x_names, y_names) && anyDuplicated(x_names) && anyDuplicated(y_names),
+    #' @section Fallbacks:
+    #' You cannot use `symdiff.duckplyr_df`
+    #' - if column names are duplicated in one of the tables
+    #' - if column names are different in both tables.
+    #'
+    #' If you do the code will fall back to `dplyr::symdiff()` without any error.
+    "Tables of different width" = length(x_names) != length(y_names),
+    "Name mismatch" = !identical(x_names, y_names) && !all(y_names %in% x_names),
     {
+      if (oo_force()) {
+        x_not_y <- anti_join(x, y, by = x_names)
+        y_not_x <- anti_join(y, x, by = x_names)
+        out <- union(x_not_y, y_not_x)
+      } else {
+        x_rel <- duckdb_rel_from_df(x)
+        y_rel <- duckdb_rel_from_df(y)
+
+        if (!identical(x_names, y_names)) {
+          # FIXME: Select by position
+          exprs <- nexprs_from_loc(x_names, set_names(seq_along(x_names), x_names))
+          y_rel <- rel_project(y_rel, exprs)
+        }
+
+        rel <- rel_set_symdiff(x_rel, y_rel)
+        out <- rel_to_df(rel)
+        out <- dplyr_reconstruct(out, x)
+      }
       return(out)
     }
   )
