
R version 4.5.2 (2025-10-31) -- "[Not] Part in a Rumble"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "duckplyr"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "duckplyr-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('duckplyr')
Loading required package: dplyr

Attaching package: ‘dplyr’

The following objects are masked from ‘package:stats’:

    filter, lag

The following objects are masked from ‘package:base’:

    intersect, setdiff, setequal, union

✔ Overwriting dplyr methods with duckplyr methods.
ℹ Turn off with `duckplyr::methods_restore()`.
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("anti_join.duckplyr_df")
> ### * anti_join.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: anti_join.duckplyr_df
> ### Title: Anti join
> ### Aliases: anti_join.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> band_members %>% anti_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 1 × 2
  name  band  
  <chr> <chr> 
1 Mick  Stones
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("anti_join.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("arrange.duckplyr_df")
> ### * arrange.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: arrange.duckplyr_df
> ### Title: Order rows using column values
> ### Aliases: arrange.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> arrange(mtcars, cyl, disp)
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
> arrange(mtcars, desc(disp))
                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb
Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Hornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Valiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Merc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Mazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Merc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Ferrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Merc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Volvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
Porsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Toyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Datsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Lotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Fiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Fiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("arrange.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as_duckplyr_df")
> ### * as_duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as_duckplyr_df
> ### Title: Convert to a duckplyr data frame
> ### Aliases: as_duckplyr_df as_duckplyr_tibble
> ### Keywords: internal
> 
> ### ** Examples
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as_duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("as_tbl")
> ### * as_tbl
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: as_tbl
> ### Title: Convert a duckplyr frame to a dbplyr table
> ### Aliases: as_tbl
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("dbplyr", quietly = TRUE)) withAutoprint({ # examplesIf
+ ## End(Don't show)
+ df <- duckdb_tibble(a = 1L)
+ df
+ 
+ tbl <- as_tbl(df)
+ tbl
+ 
+ tbl %>%
+   mutate(b = sql("a + 1")) %>%
+   as_duckdb_tibble()
+ ## Don't show: 
+ }) # examplesIf
> df <- duckdb_tibble(a = 1L)
> df
# A duckplyr data frame: 1 variable
      a
  <int>
1     1
> tbl <- as_tbl(df)
> tbl
# Source:   table<as_tbl_duckplyr_4dMaH8wQnr> [?? x 1]
# Database: DuckDB 1.4.2 [unknown@Linux 6.11.0-1018-azure:R 4.5.2//tmp/Rtmptz4Gfx/working_dir/RtmpO8ZLwh/duckplyr/duckplyr32df1b65504b.duckdb]
      a
  <int>
1     1
> tbl %>% mutate(b = sql("a + 1")) %>% as_duckdb_tibble()
# A duckplyr data frame: 2 variables
      a     b
  <int> <int>
1     1     2
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("as_tbl", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("collect.duckplyr_df")
> ### * collect.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: collect.duckplyr_df
> ### Title: Force conversion to a data frame
> ### Aliases: collect.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- duckdb_tibble(x = c(1, 2), .lazy = TRUE)
> df
# A duckplyr data frame: 2 variables
      x .lazy
  <dbl> <lgl>
1     1 TRUE 
2     2 TRUE 
> try(print(df$x))
[1] 1 2
> df <- collect(df)
> df
# A tibble: 2 × 2
      x .lazy
  <dbl> <lgl>
1     1 TRUE 
2     2 TRUE 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("collect.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compute.duckplyr_df")
> ### * compute.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compute.duckplyr_df
> ### Title: Compute results
> ### Aliases: compute.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- duckdb_tibble(x = c(1, 2))
> df <- mutate(df, y = 2)
> explain(df)
┌───────────────────────────┐
│         PROJECTION        │
│    ────────────────────   │
│             x             │
│             y             │
│                           │
│          ~2 rows          │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│     R_DATAFRAME_SCAN      │
│    ────────────────────   │
│      Text: data.frame     │
│       Projections: x      │
│                           │
│          ~2 rows          │
└───────────────────────────┘
> df <- compute(df)
> explain(df)
┌───────────────────────────┐
│         SEQ_SCAN          │
│    ────────────────────   │
│           Table:          │
│    duckplyr_4dMaH8wQnr    │
│                           │
│   Type: Sequential Scan   │
│                           │
│        Projections:       │
│             x             │
│             y             │
│                           │
│          ~2 rows          │
└───────────────────────────┘
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compute.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compute_csv")
> ### * compute_csv
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compute_csv
> ### Title: Compute results to a CSV file
> ### Aliases: compute_csv
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- data.frame(x = c(1, 2))
> df <- mutate(df, y = 2)
> path <- tempfile(fileext = ".csv")
> df <- compute_csv(df, path)
> readLines(path)
[1] "x,y"     "1.0,2.0" "2.0,2.0"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compute_csv", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("compute_parquet")
> ### * compute_parquet
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: compute_parquet
> ### Title: Compute results to a Parquet file
> ### Aliases: compute_parquet
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- data.frame(x = c(1, 2))
> df <- mutate(df, y = 2)
> path <- tempfile(fileext = ".parquet")
> df <- compute_parquet(df, path)
> explain(df)
┌───────────────────────────┐
│       READ_PARQUET        │
│    ────────────────────   │
│         Function:         │
│        READ_PARQUET       │
│                           │
│        Projections:       │
│             x             │
│             y             │
│                           │
│          ~2 rows          │
└───────────────────────────┘
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("compute_parquet", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("config")
> ### * config
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: config
> ### Title: Configuration options
> ### Aliases: config
> 
> ### ** Examples
> 
> # Sys.setenv(DUCKPLYR_OUTPUT_ORDER = TRUE)
> data.frame(a = 3:1) %>%
+   as_duckdb_tibble() %>%
+   inner_join(data.frame(a = 1:4), by = "a")
# A duckplyr data frame: 1 variable
      a
  <int>
1     1
2     2
3     3
> 
> withr::with_envvar(c(DUCKPLYR_OUTPUT_ORDER = "TRUE"), {
+   data.frame(a = 3:1) %>%
+     as_duckdb_tibble() %>%
+     inner_join(data.frame(a = 1:4), by = "a")
+ })
# A duckplyr data frame: 1 variable
      a
  <int>
1     3
2     2
3     1
> 
> # Sys.setenv(DUCKPLYR_FORCE = TRUE)
> add_one <- function(x) {
+   x + 1
+ }
> 
> data.frame(a = 3:1) %>%
+   as_duckdb_tibble() %>%
+   mutate(b = add_one(a))
# A duckplyr data frame: 2 variables
      a     b
  <int> <dbl>
1     3     4
2     2     3
3     1     2
> 
> try(withr::with_envvar(c(DUCKPLYR_FORCE = "TRUE"), {
+   data.frame(a = 3:1) %>%
+     as_duckdb_tibble() %>%
+     mutate(b = add_one(a))
+ }))
Error in mutate(., b = add_one(a)) : 
  Can't translate function `add_one()`.
> 
> # Sys.setenv(DUCKPLYR_FALLBACK_INFO = TRUE)
> withr::with_envvar(c(DUCKPLYR_FALLBACK_INFO = "TRUE"), {
+   data.frame(a = 3:1) %>%
+     as_duckdb_tibble() %>%
+     mutate(b = add_one(a))
+ })
Error processing duckplyr query with DuckDB, falling back to dplyr.
Caused by error in `mutate()`:
! Can't translate function `add_one()`.# A duckplyr data frame: 2 variables
      a     b
  <int> <dbl>
1     3     4
2     2     3
3     1     2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("config", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("count.duckplyr_df")
> ### * count.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: count.duckplyr_df
> ### Title: Count the observations in each group
> ### Aliases: count.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> count(mtcars, am)
  am  n
1  0 19
2  1 13
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("count.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("db_exec")
> ### * db_exec
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: db_exec
> ### Title: Execute a statement for the default connection
> ### Aliases: db_exec
> 
> ### ** Examples
> 
> db_exec("SET threads TO 2")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("db_exec", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("df_from_file")
> ### * df_from_file
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: df_from_file
> ### Title: Read Parquet, CSV, and other files using DuckDB
> ### Aliases: df_from_file duckplyr_df_from_file df_from_csv
> ###   duckplyr_df_from_csv df_from_parquet duckplyr_df_from_parquet
> ###   df_to_parquet
> ### Keywords: internal
> 
> ### ** Examples
> 
> # Create simple CSV file
> path <- tempfile("duckplyr_test_", fileext = ".csv")
> write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)
> 
> # Reading is immediate
> df <- df_from_csv(path)
Warning: `df_from_csv()` was deprecated in duckplyr 1.0.0.
ℹ Please use `read_csv_duckdb()` instead.
> 
> # Materialization only upon access
> names(df)
[1] "a" "b"
> df$a
[1] 1 2 3
> 
> # Return as tibble, specify column types:
> df_from_file(
+   path,
+   "read_csv",
+   options = list(delim = ",", types = list(c("DOUBLE", "VARCHAR"))),
+   class = class(tibble())
+ )
Warning: `df_from_file()` was deprecated in duckplyr 1.0.0.
ℹ Please use `read_file_duckdb()` instead.
# A tibble: 3 × 2
      a b    
  <dbl> <chr>
1     1 d    
2     2 e    
3     3 f    
> 
> # Read multiple file at once
> path2 <- tempfile("duckplyr_test_", fileext = ".csv")
> write.csv(data.frame(a = 4:6, b = letters[7:9]), path2, row.names = FALSE)
> 
> duckplyr_df_from_csv(file.path(tempdir(), "duckplyr_test_*.csv"))
Warning: `duckplyr_df_from_csv()` was deprecated in duckplyr 1.0.0.
ℹ Please use `read_csv_duckdb()` instead.
# A duckplyr data frame: 2 variables
      a b    
  <dbl> <chr>
1     4 g    
2     5 h    
3     6 i    
4     1 d    
5     2 e    
6     3 f    
> 
> unlink(c(path, path2))
> 
> # Write a Parquet file:
> path_parquet <- tempfile(fileext = ".parquet")
> df_to_parquet(df, path_parquet)
Warning: `df_to_parquet()` was deprecated in duckplyr 1.0.0.
ℹ Please use `compute_parquet()` instead.
NULL
> 
> # With a duckplyr_df, the materialization occurs outside of R:
> df %>%
+   as_duckplyr_df() %>%
+   mutate(b = a + 1) %>%
+   df_to_parquet(path_parquet)
Warning: `as_duckplyr_df()` was deprecated in duckplyr 1.0.0.
ℹ Please use `as_duckdb_tibble()` instead.
NULL
> 
> duckplyr_df_from_parquet(path_parquet)
Warning: `duckplyr_df_from_parquet()` was deprecated in duckplyr 1.0.0.
ℹ Please use `read_parquet_duckdb()` instead.
# A duckplyr data frame: 2 variables
      a     b
  <dbl> <dbl>
1     1     2
2     2     3
3     3     4
> 
> unlink(path_parquet)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("df_from_file", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("distinct.duckplyr_df")
> ### * distinct.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: distinct.duckplyr_df
> ### Title: Keep distinct/unique rows
> ### Aliases: distinct.duckplyr_df
> 
> ### ** Examples
> 
> df <- duckdb_tibble(
+   x = sample(10, 100, rep = TRUE),
+   y = sample(10, 100, rep = TRUE)
+ )
> nrow(df)
[1] 100
> nrow(distinct(df))
[1] 65
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("distinct.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("duckdb_tibble")
> ### * duckdb_tibble
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: duckdb_tibble
> ### Title: duckplyr data frames
> ### Aliases: duckdb_tibble as_duckdb_tibble is_duckdb_tibble
> 
> ### ** Examples
> 
> x <- duckdb_tibble(a = 1)
> x
# A duckplyr data frame: 1 variable
      a
  <dbl>
1     1
> 
> library(dplyr)
> x %>%
+   mutate(b = 2)
# A duckplyr data frame: 2 variables
      a     b
  <dbl> <dbl>
1     1     2
> 
> x$a
[1] 1
> 
> y <- duckdb_tibble(a = 1, .prudence = "stingy")
> y
# A duckplyr data frame: 1 variable
      a
  <dbl>
1     1
> try(length(y$a))
Error in (function (context, message, error_type = NULL, raw_message = NULL,  : 
  Materialization is disabled, use `collect()` or `as_tibble()` to materialize.
ℹ Context: GetQueryResult
> length(collect(y)$a)
[1] 1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("duckdb_tibble", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("duckplyr_execute")
> ### * duckplyr_execute
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: duckplyr_execute
> ### Title: Execute a statement for the default connection
> ### Aliases: duckplyr_execute
> ### Keywords: internal
> 
> ### ** Examples
> 
> duckplyr_execute("SET threads TO 2")
Warning: `duckplyr_execute()` was deprecated in duckplyr 1.0.0.
ℹ Please use `db_exec()` instead.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("duckplyr_execute", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("explain.duckplyr_df")
> ### * explain.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: explain.duckplyr_df
> ### Title: Explain details of a tbl
> ### Aliases: explain.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- duckdb_tibble(x = c(1, 2))
> df <- mutate(df, y = 2)
> explain(df)
┌───────────────────────────┐
│         PROJECTION        │
│    ────────────────────   │
│             x             │
│             y             │
│                           │
│          ~2 rows          │
└─────────────┬─────────────┘
┌─────────────┴─────────────┐
│     R_DATAFRAME_SCAN      │
│    ────────────────────   │
│      Text: data.frame     │
│       Projections: x      │
│                           │
│          ~2 rows          │
└───────────────────────────┘
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("explain.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("fallback")
> ### * fallback
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: fallback
> ### Title: Fallback to dplyr
> ### Aliases: fallback fallback_sitrep fallback_config fallback_review
> ###   fallback_upload fallback_purge
> 
> ### ** Examples
> 
> fallback_sitrep()
The duckplyr package is configured to fall back to dplyr when it encounters an
incompatibility. Fallback events can be collected and uploaded for analysis to
guide future development. By default, data will be collected but no data will
be uploaded.
✖ Fallback printing is disabled.
✖ Fallback logging is disabled.
✖ Automatic fallback uploading is disabled.
ℹ See `?duckplyr::fallback_config()` for details.
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("fallback", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("filter.duckplyr_df")
> ### * filter.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: filter.duckplyr_df
> ### Title: Keep rows that match a condition
> ### Aliases: filter.duckplyr_df
> 
> ### ** Examples
> 
> df <- duckdb_tibble(x = 1:3, y = 3:1)
> filter(df, x >= 2)
# A duckplyr data frame: 2 variables
      x     y
  <int> <int>
1     2     2
2     3     1
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("filter.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("flights_df")
> ### * flights_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: flights_df
> ### Title: Flight data
> ### Aliases: flights_df
> 
> ### ** Examples
> 
> ## Don't show: 
> if (requireNamespace("nycflights13", quietly = TRUE)) withAutoprint({ # examplesIf
+ ## End(Don't show)
+ flights_df()
+ ## Don't show: 
+ }) # examplesIf
> flights_df()
# A tibble: 336,776 × 19
    year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
   <int> <int> <int>    <int>          <int>     <dbl>    <int>          <int>
 1  2013     1     1      517            515         2      830            819
 2  2013     1     1      533            529         4      850            830
 3  2013     1     1      542            540         2      923            850
 4  2013     1     1      544            545        -1     1004           1022
 5  2013     1     1      554            600        -6      812            837
 6  2013     1     1      554            558        -4      740            728
 7  2013     1     1      555            600        -5      913            854
 8  2013     1     1      557            600        -3      709            723
 9  2013     1     1      557            600        -3      838            846
10  2013     1     1      558            600        -2      753            745
# ℹ 336,766 more rows
# ℹ 11 more variables: arr_delay <dbl>, carrier <chr>, flight <int>,
#   tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>, distance <dbl>,
#   hour <dbl>, minute <dbl>, time_hour <dttm>
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("flights_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("full_join.duckplyr_df")
> ### * full_join.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: full_join.duckplyr_df
> ### Title: Full join
> ### Aliases: full_join.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> full_join(band_members, band_instruments)
Joining with `by = join_by(name)`
# A tibble: 4 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
3 Mick  Stones  <NA>  
4 Keith <NA>    guitar
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("full_join.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("head.duckplyr_df")
> ### * head.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: head.duckplyr_df
> ### Title: Return the First Parts of an Object
> ### Aliases: head.duckplyr_df
> 
> ### ** Examples
> 
> head(mtcars, 2)
              mpg cyl disp  hp drat    wt  qsec vs am gear carb
Mazda RX4      21   6  160 110  3.9 2.620 16.46  0  1    4    4
Mazda RX4 Wag  21   6  160 110  3.9 2.875 17.02  0  1    4    4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("head.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("inner_join.duckplyr_df")
> ### * inner_join.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: inner_join.duckplyr_df
> ### Title: Inner join
> ### Aliases: inner_join.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> inner_join(band_members, band_instruments)
Joining with `by = join_by(name)`
# A tibble: 2 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("inner_join.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("intersect.duckplyr_df")
> ### * intersect.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: intersect.duckplyr_df
> ### Title: Intersect
> ### Aliases: intersect.duckplyr_df
> 
> ### ** Examples
> 
> df1 <- duckdb_tibble(x = 1:3)
> df2 <- duckdb_tibble(x = 3:5)
> intersect(df1, df2)
# A duckplyr data frame: 1 variable
      x
  <int>
1     3
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("intersect.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("is_duckplyr_df")
> ### * is_duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: is_duckplyr_df
> ### Title: Class predicate for duckplyr data frames
> ### Aliases: is_duckplyr_df
> ### Keywords: internal
> 
> ### ** Examples
> 
> tibble(a = 1:3) %>%
+   is_duckplyr_df()
Warning: `is_duckplyr_df()` was deprecated in duckplyr 1.0.0.
ℹ Please use `is_duckdb_tibble()` instead.
[1] FALSE
> 
> tibble(a = 1:3) %>%
+   as_duckplyr_df() %>%
+   is_duckplyr_df()
[1] TRUE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("is_duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("left_join.duckplyr_df")
> ### * left_join.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: left_join.duckplyr_df
> ### Title: Left join
> ### Aliases: left_join.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> left_join(band_members, band_instruments)
Joining with `by = join_by(name)`
# A tibble: 3 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
3 Mick  Stones  <NA>  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("left_join.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("methods_overwrite")
> ### * methods_overwrite
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: methods_overwrite
> ### Title: Forward all dplyr methods to duckplyr
> ### Aliases: methods_overwrite methods_restore
> 
> ### ** Examples
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> methods_overwrite()
✔ Overwriting dplyr methods with duckplyr methods.
ℹ Turn off with `duckplyr::methods_restore()`.
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> methods_restore()
ℹ Restoring dplyr methods.
> 
> tibble(a = 1:3) %>%
+   mutate(b = a + 1)
# A tibble: 3 × 2
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("methods_overwrite", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("mutate.duckplyr_df")
> ### * mutate.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: mutate.duckplyr_df
> ### Title: Create, modify, and delete columns
> ### Aliases: mutate.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- data.frame(x = c(1, 2))
> df <- mutate(df, y = 2)
> df
  x y
1 1 2
2 2 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("mutate.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("new_relational")
> ### * new_relational
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: new_relational
> ### Title: Relational implementer's interface
> ### Aliases: new_relational rel_to_df rel_filter rel_project rel_aggregate
> ###   rel_order rel_join rel_limit rel_distinct rel_set_intersect
> ###   rel_set_diff rel_set_symdiff rel_union_all rel_explain rel_alias
> ###   rel_set_alias rel_names
> 
> ### ** Examples
> 
> new_dfrel <- function(x) {
+   stopifnot(is.data.frame(x))
+   new_relational(list(x), class = "dfrel")
+ }
> mtcars_rel <- new_dfrel(mtcars[1:5, 1:4])
> 
> rel_to_df.dfrel <- function(rel, ...) {
+   unclass(rel)[[1]]
+ }
> rel_to_df(mtcars_rel)
                   mpg cyl disp  hp
Mazda RX4         21.0   6  160 110
Mazda RX4 Wag     21.0   6  160 110
Datsun 710        22.8   4  108  93
Hornet 4 Drive    21.4   6  258 110
Hornet Sportabout 18.7   8  360 175
> 
> rel_filter.dfrel <- function(rel, exprs, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   # A real implementation would evaluate the predicates defined
+   # by the exprs argument
+   new_dfrel(df[seq_len(min(3, nrow(df))), ])
+ }
> 
> rel_filter(
+   mtcars_rel,
+   list(
+     relexpr_function(
+       "gt",
+       list(relexpr_reference("cyl"), relexpr_constant("6"))
+     )
+   )
+ )
[[1]]
               mpg cyl disp  hp
Mazda RX4     21.0   6  160 110
Mazda RX4 Wag 21.0   6  160 110
Datsun 710    22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_project.dfrel <- function(rel, exprs, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   # A real implementation would evaluate the expressions defined
+   # by the exprs argument
+   new_dfrel(df[seq_len(min(3, ncol(df)))])
+ }
> 
> rel_project(
+   mtcars_rel,
+   list(relexpr_reference("cyl"), relexpr_reference("disp"))
+ )
[[1]]
                   mpg cyl disp
Mazda RX4         21.0   6  160
Mazda RX4 Wag     21.0   6  160
Datsun 710        22.8   4  108
Hornet 4 Drive    21.4   6  258
Hornet Sportabout 18.7   8  360

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_order.dfrel <- function(rel, exprs, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   # A real implementation would evaluate the expressions defined
+   # by the exprs argument
+   new_dfrel(df[order(df[[1]]), ])
+ }
> 
> rel_order(
+   mtcars_rel,
+   list(relexpr_reference("mpg"))
+ )
[[1]]
                   mpg cyl disp  hp
Hornet Sportabout 18.7   8  360 175
Mazda RX4         21.0   6  160 110
Mazda RX4 Wag     21.0   6  160 110
Hornet 4 Drive    21.4   6  258 110
Datsun 710        22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> ## Don't show: 
> if (requireNamespace("dplyr", quietly = TRUE)) withAutoprint({ # examplesIf
+ ## End(Don't show)
+ rel_join.dfrel <- function(left, right, conds, join, ...) {
+   left_df <- unclass(left)[[1]]
+   right_df <- unclass(right)[[1]]
+ 
+   # A real implementation would evaluate the expressions
+   # defined by the conds argument,
+   # use different join types based on the join argument,
+   # and implement the join itself instead of relaying to left_join().
+   new_dfrel(dplyr::left_join(left_df, right_df))
+ }
+ 
+ rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)
+ ## Don't show: 
+ }) # examplesIf
> rel_join.dfrel <- function(left, right, conds, join, ...) {
+     left_df <- unclass(left)[[1]]
+     right_df <- unclass(right)[[1]]
+     new_dfrel(dplyr::left_join(left_df, right_df))
+ }
> rel_join(new_dfrel(data.frame(mpg = 21)), mtcars_rel)
Joining with `by = join_by(mpg)`
[[1]]
  mpg cyl disp  hp
1  21   6  160 110
2  21   6  160 110

attr(,"class")
[1] "dfrel"      "relational"
> ## End(Don't show)
> 
> rel_limit.dfrel <- function(rel, n, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   new_dfrel(df[seq_len(n), ])
+ }
> 
> rel_limit(mtcars_rel, 3)
[[1]]
               mpg cyl disp  hp
Mazda RX4     21.0   6  160 110
Mazda RX4 Wag 21.0   6  160 110
Datsun 710    22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_distinct.dfrel <- function(rel, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   new_dfrel(df[!duplicated(df), ])
+ }
> 
> rel_distinct(new_dfrel(mtcars[1:3, 1:4]))
[[1]]
            mpg cyl disp  hp
Mazda RX4  21.0   6  160 110
Datsun 710 22.8   4  108  93

attr(,"class")
[1] "dfrel"      "relational"
> 
> rel_names.dfrel <- function(rel, ...) {
+   df <- unclass(rel)[[1]]
+ 
+   names(df)
+ }
> 
> rel_names(mtcars_rel)
[1] "mpg"  "cyl"  "disp" "hp"  
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("new_relational", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("new_relexpr")
> ### * new_relexpr
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: new_relexpr
> ### Title: Relational expressions
> ### Aliases: new_relexpr relexpr_reference relexpr_constant
> ###   relexpr_function relexpr_comparison relexpr_window relexpr_set_alias
> 
> ### ** Examples
> 
> relexpr_set_alias(
+   alias = "my_predicate",
+   relexpr_function(
+     "<",
+     list(
+       relexpr_reference("my_number"),
+       relexpr_constant(42)
+     )
+   )
+ )
List of 3
 $ name : chr "<"
 $ args :List of 2
  ..$ :List of 3
  .. ..$ name : chr "my_number"
  .. ..$ rel  : NULL
  .. ..$ alias: NULL
  .. ..- attr(*, "class")= chr [1:2] "relational_relexpr_reference" "relational_relexpr"
  ..$ :List of 2
  .. ..$ val  : num 42
  .. ..$ alias: NULL
  .. ..- attr(*, "class")= chr [1:2] "relational_relexpr_constant" "relational_relexpr"
 $ alias: chr "my_predicate"
 - attr(*, "class")= chr [1:2] "relational_relexpr_function" "relational_relexpr"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("new_relexpr", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("pull.duckplyr_df")
> ### * pull.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: pull.duckplyr_df
> ### Title: Extract a single column
> ### Aliases: pull.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> pull(mtcars, cyl)
 [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4
> pull(mtcars, 1)
 [1] 21.0 21.0 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 17.8 16.4 17.3 15.2 10.4
[16] 10.4 14.7 32.4 30.4 33.9 21.5 15.5 15.2 13.3 19.2 27.3 26.0 30.4 15.8 19.7
[31] 15.0 21.4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("pull.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read_csv_duckdb")
> ### * read_csv_duckdb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read_csv_duckdb
> ### Title: Read CSV files using DuckDB
> ### Aliases: read_csv_duckdb
> 
> ### ** Examples
> 
> # Create simple CSV file
> path <- tempfile("duckplyr_test_", fileext = ".csv")
> write.csv(data.frame(a = 1:3, b = letters[4:6]), path, row.names = FALSE)
> 
> # Reading is immediate
> df <- read_csv_duckdb(path)
> 
> # Names are always available
> names(df)
[1] "a" "b"
> 
> # Materialization upon access is turned off by default
> try(print(df$a))
[1] 1 2 3
> 
> # Materialize explicitly
> collect(df)$a
[1] 1 2 3
> 
> # Automatic materialization with prudence = "lavish"
> df <- read_csv_duckdb(path, prudence = "lavish")
> df$a
[1] 1 2 3
> 
> # Specify column types
> read_csv_duckdb(
+   path,
+   options = list(delim = ",", types = list(c("DOUBLE", "VARCHAR")))
+ )
# A duckplyr data frame: 2 variables
      a b    
  <dbl> <chr>
1     1 d    
2     2 e    
3     3 f    
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read_csv_duckdb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read_json_duckdb")
> ### * read_json_duckdb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read_json_duckdb
> ### Title: Read JSON files using DuckDB
> ### Aliases: read_json_duckdb
> 
> ### ** Examples
> 
> ## Don't show: 
> if (identical(Sys.getenv("IN_PKGDOWN"), "TRUE")) withAutoprint({ # examplesIf
+ ## End(Don't show)
+ 
+ # Create and read a simple JSON file
+ path <- tempfile("duckplyr_test_", fileext = ".json")
+ writeLines('[{"a": 1, "b": "x"}, {"a": 2, "b": "y"}]', path)
+ 
+ # Reading needs the json extension
+ db_exec("INSTALL json")
+ db_exec("LOAD json")
+ read_json_duckdb(path)
+ ## Don't show: 
+ }) # examplesIf
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read_json_duckdb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read_sql_duckdb")
> ### * read_sql_duckdb
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read_sql_duckdb
> ### Title: Return SQL query as duckdb_tibble
> ### Aliases: read_sql_duckdb
> 
> ### ** Examples
> 
> ## Don't show: 
> if (getRversion() >= "4.3") withAutoprint({ # examplesIf
+ ## End(Don't show)
+ read_sql_duckdb("FROM duckdb_settings()")
+ ## Don't show: 
+ }) # examplesIf
> read_sql_duckdb("FROM duckdb_settings()")
# A duckplyr data frame: 6 variables
   name                               value description input_type scope aliases
   <chr>                              <chr> <chr>       <chr>      <chr> <list> 
 1 access_mode                        auto… Access mod… VARCHAR    GLOB… <chr>  
 2 allocator_background_threads       false Whether to… BOOLEAN    GLOB… <chr>  
 3 allocator_bulk_deallocation_flush… 512.… If a bulk … VARCHAR    GLOB… <chr>  
 4 allocator_flush_threshold          128.… Peak alloc… VARCHAR    GLOB… <chr>  
 5 allow_community_extensions         true  Allow to l… BOOLEAN    GLOB… <chr>  
 6 allow_extensions_metadata_mismatch false Allow to l… BOOLEAN    GLOB… <chr>  
 7 allow_persistent_secrets           true  Allow the … BOOLEAN    GLOB… <chr>  
 8 allow_unredacted_secrets           false Allow prin… BOOLEAN    GLOB… <chr>  
 9 allow_unsigned_extensions          false Allow to l… BOOLEAN    GLOB… <chr>  
10 allowed_directories                []    List of di… VARCHAR[]  GLOB… <chr>  
# ℹ more rows
> ## End(Don't show)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read_sql_duckdb", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("relocate.duckplyr_df")
> ### * relocate.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: relocate.duckplyr_df
> ### Title: Change column order
> ### Aliases: relocate.duckplyr_df
> 
> ### ** Examples
> 
> df <- duckdb_tibble(a = 1, b = 1, c = 1, d = "a", e = "a", f = "a")
> relocate(df, f)
# A duckplyr data frame: 6 variables
  f         a     b     c d     e    
  <chr> <dbl> <dbl> <dbl> <chr> <chr>
1 a         1     1     1 a     a    
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("relocate.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("rename.duckplyr_df")
> ### * rename.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: rename.duckplyr_df
> ### Title: Rename columns
> ### Aliases: rename.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> rename(mtcars, thing = mpg)
                    thing cyl  disp  hp drat    wt  qsec vs am gear carb
Mazda RX4            21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4
Mazda RX4 Wag        21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4
Datsun 710           22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1
Hornet 4 Drive       21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1
Hornet Sportabout    18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2
Valiant              18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1
Duster 360           14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4
Merc 240D            24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2
Merc 230             22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2
Merc 280             19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4
Merc 280C            17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4
Merc 450SE           16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3
Merc 450SL           17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3
Merc 450SLC          15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3
Cadillac Fleetwood   10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4
Lincoln Continental  10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4
Chrysler Imperial    14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4
Fiat 128             32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1
Honda Civic          30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2
Toyota Corolla       33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1
Toyota Corona        21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1
Dodge Challenger     15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2
AMC Javelin          15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2
Camaro Z28           13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4
Pontiac Firebird     19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2
Fiat X1-9            27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1
Porsche 914-2        26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2
Lotus Europa         30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2
Ford Pantera L       15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4
Ferrari Dino         19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6
Maserati Bora        15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8
Volvo 142E           21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("rename.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("right_join.duckplyr_df")
> ### * right_join.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: right_join.duckplyr_df
> ### Title: Right join
> ### Aliases: right_join.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> right_join(band_members, band_instruments)
Joining with `by = join_by(name)`
# A tibble: 3 × 3
  name  band    plays 
  <chr> <chr>   <chr> 
1 John  Beatles guitar
2 Paul  Beatles bass  
3 Keith <NA>    guitar
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("right_join.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("select.duckplyr_df")
> ### * select.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: select.duckplyr_df
> ### Title: Keep or drop columns using their names and types
> ### Aliases: select.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> select(mtcars, mpg)
                     mpg
Mazda RX4           21.0
Mazda RX4 Wag       21.0
Datsun 710          22.8
Hornet 4 Drive      21.4
Hornet Sportabout   18.7
Valiant             18.1
Duster 360          14.3
Merc 240D           24.4
Merc 230            22.8
Merc 280            19.2
Merc 280C           17.8
Merc 450SE          16.4
Merc 450SL          17.3
Merc 450SLC         15.2
Cadillac Fleetwood  10.4
Lincoln Continental 10.4
Chrysler Imperial   14.7
Fiat 128            32.4
Honda Civic         30.4
Toyota Corolla      33.9
Toyota Corona       21.5
Dodge Challenger    15.5
AMC Javelin         15.2
Camaro Z28          13.3
Pontiac Firebird    19.2
Fiat X1-9           27.3
Porsche 914-2       26.0
Lotus Europa        30.4
Ford Pantera L      15.8
Ferrari Dino        19.7
Maserati Bora       15.0
Volvo 142E          21.4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("select.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("semi_join.duckplyr_df")
> ### * semi_join.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: semi_join.duckplyr_df
> ### Title: Semi join
> ### Aliases: semi_join.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> band_members %>% semi_join(band_instruments)
Joining with `by = join_by(name)`
# A tibble: 2 × 2
  name  band   
  <chr> <chr>  
1 John  Beatles
2 Paul  Beatles
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("semi_join.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("setdiff.duckplyr_df")
> ### * setdiff.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: setdiff.duckplyr_df
> ### Title: Set difference
> ### Aliases: setdiff.duckplyr_df
> 
> ### ** Examples
> 
> df1 <- duckdb_tibble(x = 1:3)
> df2 <- duckdb_tibble(x = 3:5)
> setdiff(df1, df2)
# A duckplyr data frame: 1 variable
      x
  <int>
1     1
2     2
> setdiff(df2, df1)
# A duckplyr data frame: 1 variable
      x
  <int>
1     4
2     5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("setdiff.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("slice_head.duckplyr_df")
> ### * slice_head.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: slice_head.duckplyr_df
> ### Title: Subset rows using their positions
> ### Aliases: slice_head.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> df <- data.frame(x = 1:3)
> df <- slice_head(df, n = 2)
> df
  x
1 1
2 2
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("slice_head.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("stats_show")
> ### * stats_show
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: stats_show
> ### Title: Show stats
> ### Aliases: stats_show
> 
> ### ** Examples
> 
> stats_show()
🛠: 53
🔨:  7
🦆: 46
anti_join.data.frame, arrange.data.frame, compute, count.data.frame, distinct, explain, filter, full_join.data.frame, group_by.data.frame, head, inner_join, inner_join.data.frame, intersect, left_join.data.frame, mutate, mutate.data.frame, relocate, setdiff
> 
> tibble(a = 1:3) %>%
+   as_duckplyr_tibble() %>%
+   mutate(b = a + 1)
Warning: `as_duckplyr_tibble()` was deprecated in duckplyr 1.0.0.
ℹ Please use `as_duckdb_tibble()` instead.
# A duckplyr data frame: 2 variables
      a     b
  <int> <dbl>
1     1     2
2     2     3
3     3     4
> 
> stats_show()
🛠: 55
🔨:  7
🦆: 48
anti_join.data.frame, arrange.data.frame, compute, count.data.frame, distinct, explain, filter, full_join.data.frame, group_by.data.frame, head, inner_join, inner_join.data.frame, intersect, left_join.data.frame, mutate, mutate.data.frame, relocate, setdiff
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("stats_show", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("summarise.duckplyr_df")
> ### * summarise.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: summarise.duckplyr_df
> ### Title: Summarise each group down to one row
> ### Aliases: summarise.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> summarise(mtcars, mean = mean(disp), n = n())
      mean  n
1 230.7219 32
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("summarise.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("symdiff.duckplyr_df")
> ### * symdiff.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: symdiff.duckplyr_df
> ### Title: Symmetric difference
> ### Aliases: symdiff.duckplyr_df
> 
> ### ** Examples
> 
> df1 <- duckdb_tibble(x = 1:3)
> df2 <- duckdb_tibble(x = 3:5)
> symdiff(df1, df2)
# A duckplyr data frame: 1 variable
      x
  <int>
1     2
2     5
3     1
4     4
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("symdiff.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("transmute.duckplyr_df")
> ### * transmute.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: transmute.duckplyr_df
> ### Title: Create, modify, and delete columns
> ### Aliases: transmute.duckplyr_df
> 
> ### ** Examples
> 
> library(duckplyr)
> transmute(mtcars, mpg2 = mpg*2)
                    mpg2
Mazda RX4           42.0
Mazda RX4 Wag       42.0
Datsun 710          45.6
Hornet 4 Drive      42.8
Hornet Sportabout   37.4
Valiant             36.2
Duster 360          28.6
Merc 240D           48.8
Merc 230            45.6
Merc 280            38.4
Merc 280C           35.6
Merc 450SE          32.8
Merc 450SL          34.6
Merc 450SLC         30.4
Cadillac Fleetwood  20.8
Lincoln Continental 20.8
Chrysler Imperial   29.4
Fiat 128            64.8
Honda Civic         60.8
Toyota Corolla      67.8
Toyota Corona       43.0
Dodge Challenger    31.0
AMC Javelin         30.4
Camaro Z28          26.6
Pontiac Firebird    38.4
Fiat X1-9           54.6
Porsche 914-2       52.0
Lotus Europa        60.8
Ford Pantera L      31.6
Ferrari Dino        39.4
Maserati Bora       30.0
Volvo 142E          42.8
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("transmute.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("union.duckplyr_df")
> ### * union.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: union.duckplyr_df
> ### Title: Union
> ### Aliases: union.duckplyr_df
> 
> ### ** Examples
> 
> df1 <- duckdb_tibble(x = 1:3)
> df2 <- duckdb_tibble(x = 3:5)
> union(df1, df2)
# A duckplyr data frame: 1 variable
      x
  <int>
1     1
2     3
3     4
4     2
5     5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("union.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("union_all.duckplyr_df")
> ### * union_all.duckplyr_df
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: union_all.duckplyr_df
> ### Title: Union of all
> ### Aliases: union_all.duckplyr_df
> 
> ### ** Examples
> 
> df1 <- duckdb_tibble(x = 1:3)
> df2 <- duckdb_tibble(x = 3:5)
> union_all(df1, df2)
# A duckplyr data frame: 1 variable
      x
  <int>
1     1
2     2
3     3
4     3
5     4
6     5
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("union_all.duckplyr_df", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  6.357 0.17 6.516 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
