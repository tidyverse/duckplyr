# Generated by 02-duckplyr_df-methods.R
#' @export
compute.duckplyr_df <- function(x, ..., name = NULL, temporary = TRUE) {
  if (is.null(name)) {
    if (!isTRUE(temporary)) {
      cli::cli_abort("{.arg name} must be provided if {.arg temporary} is {.val {FALSE}}.")
    }
    name <- unique_table_name()
  }
  stopifnot(!is.null(name) || !isTRUE(temporary))

  con <- get_default_duckdb_connection()
  quoted <- DBI::dbQuoteIdentifier(con, name)
  unquoted <- DBI::dbUnquoteIdentifier(con, quoted)[[1]]
  if (length(unquoted) == 1) {
    schema <- ""
    table <- unquoted@name[[1]]
  } else if (length(unquoted) == 2) {
    schema <- unquoted@name[[1]]
    table <- unquoted@name[[2]]
  } else {
    cli::cli_abort('{.arg name} must be either a string or of the form {.code SQL("schema.table")}')
  }

  # Our implementation
  rel_try(NULL,
    {
      sql <- paste0(
        "CREATE ",
        if (isTRUE(temporary)) "TEMPORARY ",
        "TABLE ",
        quoted,
        " AS FROM _"
      )
      rel <- duckdb_rel_from_df(x)
      duckdb$rel_sql(rel, sql)
      out_rel <- duckdb$rel_from_table(con, table_name = table, schema_name = schema)
      out <- rel_to_df(out_rel)
      out <- dplyr_reconstruct(out, x)
      return(out)
    }
  )

  # dplyr forward
  compute <- dplyr$compute.data.frame
  out <- compute(x, ...)
  return(out)

  # dplyr implementation
  x
}

duckplyr_compute <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- compute(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}
