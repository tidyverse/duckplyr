# Generated by 02-duckplyr_df-methods.R
#' @rdname compute.duckplyr_df
#' @export
compute.duckplyr_df <- function(
  x,
  ...,
  tether = NULL,
  name = NULL,
  schema_name = NULL,
  temporary = TRUE
) {
  # Our implementation
  duckplyr_error <- rel_try(NULL,
    "Needs duckdb >= 1.1.3.9029" = !is_installed("duckdb", version = "1.1.3.9029"),
    {
      if (is.null(tether)) {
        tether <- is_tethered_duckplyr_df(x)
      }
      if (is.null(schema_name)) {
        schema_name <- ""
      }
      if (is.null(name)) {
        if (isTRUE(temporary)) {
          name <- unique_table_name()
        } else {
          cli::cli_abort("{.arg name} must be provided if {.arg temporary} is {.value FALSE}")
        }
      }

      rel <- duckdb_rel_from_df(x)

      duckdb$rel_to_table(rel, schema_name, name, temporary)

      # API inconsistency: order of name and schema_name
      out_rel <- duckdb$rel_from_table(get_default_duckdb_connection(), name, schema_name)

      out <- duckplyr_reconstruct(out_rel, x)

      if (is_tethered_duckplyr_df(out) != tether) {
        out <- as_duckdb_tibble(out, tether = tether)
      }

      return(out)
    }
  )

  # dplyr forward
  check_tethered(x, duckplyr_error)

  compute <- dplyr$compute.data.frame
  out <- compute(x, ...)
  return(out)

  # dplyr implementation
  x
}

duckplyr_compute <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df_impl(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- compute(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}
