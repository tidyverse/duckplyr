# Generated by 02-duckplyr_df-methods.R
#' @rdname compute.duckplyr_df
#' @export
compute.duckplyr_df <- function(
  x,
  ...,
  funnel = NULL,
  name = NULL,
  schema_name = NULL,
  temporary = TRUE
) {
  funnel <- funnel %||% get_funnel_duckplyr_df(x)

  schema_name <- schema_name %||% ""

  if (is.null(name)) {
    if (isTRUE(temporary)) {
      name <- unique_table_name()
    } else {
      cli::cli_abort("{.arg name} must be provided if {.arg temporary} is {.value FALSE}")
    }
  }

  # Our implementation
  duckplyr_error <- rel_try(NULL,
    {
      rel <- duckdb_rel_from_df(x)

      duckdb$rel_to_table(rel, schema_name, name, temporary)

      # API inconsistency: order of name and schema_name
      out_rel <- duckdb$rel_from_table(get_default_duckdb_connection(), name, schema_name)

      out <- duckplyr_reconstruct(out_rel, x)

      if (get_funnel_duckplyr_df(out) != funnel) {
        out <- as_duckdb_tibble(out, funnel = funnel)
      }

      return(out)
    }
  )

  # dplyr forward
  check_funneled(x, duckplyr_error)

  compute <- dplyr$compute.data.frame
  out <- compute(x, ...)
  return(out)

  # dplyr implementation
  x
}

duckplyr_compute <- function(x, ...) {
  try_fetch(
    x <- as_duckplyr_df_impl(x),
    error = function(e) {
      testthat::skip(conditionMessage(e))
    }
  )
  out <- compute(x, ...)
  class(out) <- setdiff(class(out), "duckplyr_df")
  out
}
